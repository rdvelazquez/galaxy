{"version":3,"sources":["utils/deferred.js"],"names":["Backbone","Model","extend","initialize","active","last","execute","callback","self","id","uid","has_deferred","length","process","$","Deferred","promise","always","Galaxy","emit","debug","state","charAt","toUpperCase","slice","when","resolve","reject","reset","i","ready","isEmptyObject"],"mappings":";;;;;;;;;;;;;;;sBAIeA,SAASC,KAAT,CAAeC,MAAf,CAAsB;AACjCC,oBAAY,sBAAW;AACnB,iBAAKC,MAAL,GAAc,EAAd;AACA,iBAAKC,IAAL,GAAY,IAAZ;AACH,SAJgC;;AAMjC;;;AAGAC,iBAAS,iBAASC,QAAT,EAAmB;AACxB,gBAAIC,OAAO,IAAX;AACA,gBAAIC,KAAK,gBAAMC,GAAN,EAAT;AACA,gBAAIC,eAAeJ,SAASK,MAAT,GAAkB,CAArC;;AAEA;AACA,iBAAKR,MAAL,CAAYK,EAAZ,IAAkB,IAAlB;;AAEA;AACA,gBAAII,UAAUC,EAAEC,QAAF,EAAd;AACAF,oBAAQG,OAAR,GAAkBC,MAAlB,CAAyB,YAAW;AAChC,uBAAOT,KAAKJ,MAAL,CAAYK,EAAZ,CAAP;AACAE,gCACIO,OAAOC,IAAP,CAAYC,KAAZ,CACI,qBADJ,EAEO,KAAKC,KAAL,GACEC,MADF,CACS,CADT,EAEEC,WAFF,KAEkB,KAAKF,KAAL,GAAaG,KAAb,CAAmB,CAAnB,CAJzB,SAIkDf,EAJlD,CADJ;AAOH,aATD;;AAWA;AACAK,cAAEW,IAAF,CAAO,KAAKpB,IAAZ,EAAkBY,MAAlB,CAAyB,YAAM;AAC3B,oBAAIT,KAAKJ,MAAL,CAAYK,EAAZ,CAAJ,EAAqB;AACjBE,oCAAgBO,OAAOC,IAAP,CAAYC,KAAZ,CAAkB,qBAAlB,eAAoDX,EAApD,CAAhB;AACAF,6BAASM,OAAT;AACA,qBAACF,YAAD,IAAiBE,QAAQa,OAAR,EAAjB;AACH,iBAJD,MAIO;AACHb,4BAAQc,MAAR;AACH;AACJ,aARD;AASA,iBAAKtB,IAAL,GAAYQ,QAAQG,OAAR,EAAZ;AACH,SAzCgC;;AA2CjC;;AAEAY,eAAO,iBAAW;AACdV,mBAAOC,IAAP,CAAYC,KAAZ,CAAkB,qBAAlB,EAAyC,OAAzC;AACA,iBAAK,IAAIS,CAAT,IAAc,KAAKzB,MAAnB,EAA2B;AACvB,qBAAKA,MAAL,CAAYyB,CAAZ,IAAiB,KAAjB;AACH;AACJ,SAlDgC;;AAoDjC;;AAEAC,eAAO,iBAAW;AACd,mBAAOhB,EAAEiB,aAAF,CAAgB,KAAK3B,MAArB,CAAP;AACH;AAxDgC,KAAtB,C","file":"../../scripts/utils/deferred.js","sourcesContent":["/**\n *  This class defines a queue to ensure that multiple deferred callbacks are executed sequentially.\n */\nimport Utils from \"utils/utils\";\nexport default Backbone.Model.extend({\n    initialize: function() {\n        this.active = {};\n        this.last = null;\n    },\n\n    /** Adds a callback to the queue. Upon execution a deferred object is parsed to the callback i.e. callback( deferred ).\n     *  If the callback does not take any arguments, the deferred is resolved instantly.\n     */\n    execute: function(callback) {\n        var self = this;\n        var id = Utils.uid();\n        var has_deferred = callback.length > 0;\n\n        // register process\n        this.active[id] = true;\n\n        // deferred process\n        var process = $.Deferred();\n        process.promise().always(function() {\n            delete self.active[id];\n            has_deferred &&\n                Galaxy.emit.debug(\n                    \"deferred::execute()\",\n                    `${this.state()\n                        .charAt(0)\n                        .toUpperCase() + this.state().slice(1)} ${id}`\n                );\n        });\n\n        // deferred queue\n        $.when(this.last).always(() => {\n            if (self.active[id]) {\n                has_deferred && Galaxy.emit.debug(\"deferred::execute()\", `Running ${id}`);\n                callback(process);\n                !has_deferred && process.resolve();\n            } else {\n                process.reject();\n            }\n        });\n        this.last = process.promise();\n    },\n\n    /** Resets the promise queue. All currently queued but unexecuted callbacks/promises will be rejected.\n     */\n    reset: function() {\n        Galaxy.emit.debug(\"deferred::execute()\", \"Reset\");\n        for (var i in this.active) {\n            this.active[i] = false;\n        }\n    },\n\n    /** Returns true if all processes are done.\n     */\n    ready: function() {\n        return $.isEmptyObject(this.active);\n    }\n});\n"]}