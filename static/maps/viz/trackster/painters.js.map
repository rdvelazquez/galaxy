{"version":3,"sources":["viz/trackster/painters.js"],"names":["_","BEFORE","CONTAINS","OVERLAP_START","OVERLAP_END","CONTAINED_BY","AFTER","DENSE_TRACK_HEIGHT","NO_DETAIL_TRACK_HEIGHT","SQUISH_TRACK_HEIGHT","PACK_TRACK_HEIGHT","NO_DETAIL_FEATURE_HEIGHT","DENSE_FEATURE_HEIGHT","SQUISH_FEATURE_HEIGHT","PACK_FEATURE_HEIGHT","LABEL_SPACING","CONNECTOR_COLOR","compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","overlap","is_overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","dX","dY","dashes","Math","floor","sqrt","dashX","dashY","q","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","fillStyle","fill","stroke","closePath","Scaler","default_val","input","DrawResults","options","incomplete_features","feature_mapper","Painter","data","view_start","view_end","prefs","mode","default_prefs","extend","width","height","w_scale","chrom_pos","_chrom_pos_to_draw_pos","offset","max","LinePainter","in_path","min_value","max_value","vertical_range","height_px","save","y_zero","round","x_scaled","delta_x_pxs","length","map","slice","d","i","ceil","painter_color","block_color","color","pref_color","parseInt","pref_r","pref_g","pref_b","top_overflow","bot_overflow","delta_x_px","len","saturation","new_r","new_g","new_b","overflow_color","overflow_x","restore","FeaturePositionMapper","slot_height","feature_positions","translation","y_translation","feature_data","slot","x_start","x_end","push","x","feature_dict","FeaturePainter","alpha_scaler","height_scaler","max_label_length","rows_required","required_height","get_row_height","y_scale","get_top_padding","slots","textAlign","x_draw_coords","feature","feature_uid","feature_start","feature_end","draw_element","map_feature_data","tile_low","tile_high","connector_color","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","feature_name","feature_strand","f_start","f_end","min","draw_start","draw_end","y_start","thick_start","thick_end","reverse_strand_color","label_color","globalAlpha","gen_val","feature_ts","feature_te","feature_blocks","full_height","thin_height","thick_height","canvas","manager","get_pattern","cur_y_start","cur_height","k","k_len","block","block_start","block_end","last_block_start","last_block_end","block_thick_start","block_thick_end","draw_connector","hscale_factor","new_height","ws_height","measureText","fillText","ReadPainter","ref_seq","base_color_fn","show_insertions","cigar_str","cigar_ops","blocks","cur_block","base_pos","parsed_cigar","match","op_len","op","op_char","indexOf","cigar","strand","read_seq","update_base_offset","cig_op","cig_len","update_seq_offset","get_draw_coord","sequence_coord","tile_region","base_offset","seq_offset","gap","char_width_px","detail_block_color","pack_mode","draw_height","rect_y","paint_utils","ReadPainterUtils","drawing_blocks","s_start","s_end","draw_last","t","_parse_cigar","cig_id","cig","seq_start","cur_seq","start_pos","c","show_differences","c_start","draw_deletion","insert_x_coord","seq","x_center","type","str_len","item","font","Array","connector","draw_read","b1_end","b2_start","line_height","ArcLinkedFeaturePainter","longest_feature_length","calculate_longest_feature_length","view_range","block1_start","block1_end","block2_start","block2_end","radius","arc","PI","Color","rgb","a","isArray","substring","split","alpha","concat","join","toString","r","g","b","h","s","l","argb","color2","weight","color1","p","w","toHSL","w1","w2","LinearRamp","start_color","end_color","start_value","end_value","value_range","value","mix","toCSS","SplitRamp","middle_color","positive_ramp","negative_ramp","map_value","DiagonalHeatmapPainter","Infinity","invsqrt2","ramp","neg_color","pos_color","s1","e1","s2","e2","scale","rotate","row_height","px_per_base","draw_details","delete_details_thickness","thickness","VariantPainter","divider_height","num_samples","summary_height","show_sample_data","get_indel_info","ref","alt","ref_len","alt_len","start","locus_data","pos","sample_gts","allele_counts","variant","draw_x_start","draw_y_start","genotype","base_px","feature_height","draw_summary","j","flatten","alt_info","indel_info","get_start_draw_pos","allele_frac","snp","get_draw_pos"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import * as _ from \"libs/underscore\";\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nconst BEFORE = 1001;\nconst CONTAINS = 1002;\nconst OVERLAP_START = 1003;\nconst OVERLAP_END = 1004;\nconst CONTAINED_BY = 1005;\nconst AFTER = 1006;\n\nconst DENSE_TRACK_HEIGHT = 10;\nconst NO_DETAIL_TRACK_HEIGHT = 3;\nconst SQUISH_TRACK_HEIGHT = 5;\nconst PACK_TRACK_HEIGHT = 10;\nconst NO_DETAIL_FEATURE_HEIGHT = 1;\nconst DENSE_FEATURE_HEIGHT = 9;\nconst SQUISH_FEATURE_HEIGHT = 3;\nconst PACK_FEATURE_HEIGHT = 9;\nconst LABEL_SPACING = 2;\nconst CONNECTOR_COLOR = \"#ccc\";\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nfunction compute_overlap(first_region, second_region) {\n    var first_start = first_region[0];\n    var first_end = first_region[1];\n    var second_start = second_region[0];\n    var second_end = second_region[1];\n    var overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n    return overlap;\n}\n\n/**\n * Returns true if regions overlap.\n */\nfunction is_overlap(first_region, second_region) {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n}\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nfunction dashedLine(ctx, x1, y1, x2, y2, dashLen) {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n}\n\n/**\n * Draw an isosceles triangle that points down.\n */\nfunction drawDownwardEquilateralTriangle(ctx, down_vertex_x, down_vertex_y, side_len) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2;\n\n    var x2 = down_vertex_x + side_len / 2;\n    var y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n}\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nclass Scaler {\n    constructor(default_val) {\n        this.default_val = default_val ? default_val : 1;\n    }\n\n    /**\n     * Produce a scaling value.\n     */\n    gen_val(input) {\n        return this.default_val;\n    }\n}\n\n/**\n * Results from painter.draw()\n */\nclass DrawResults {\n    constructor(options) {\n        this.incomplete_features = options.incomplete_features;\n        this.feature_mapper = options.feature_mapper;\n    }\n}\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nclass Painter {\n    constructor(data, view_start, view_end, prefs, mode) {\n        // Data and data properties\n        this.data = data;\n        this.default_prefs = {};\n        // View\n        this.view_start = view_start;\n        this.view_end = view_end;\n        // Drawing prefs\n        this.prefs = _.extend({}, this.default_prefs, prefs);\n        this.mode = mode;\n    }\n\n    static get default_prefs() {\n        return {};\n    }\n\n    /**\n     * Draw on the context using a rectangle of width x height using scale w_scale.\n     */\n    draw(ctx, width, height, w_scale) {}\n\n    /**\n     * Get starting drawing position, which is offset a half-base left of coordinate.\n     */\n    get_start_draw_pos(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n    }\n\n    /**\n     * Get end drawing position, which is offset a half-base right of coordinate.\n     */\n    get_end_draw_pos(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n    }\n\n    /**\n     * Get drawing position.\n     */\n    get_draw_pos(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n    }\n\n    /**\n     * Convert chromosome position to drawing position.\n     */\n    _chrom_pos_to_draw_pos(chrom_pos, w_scale, offset) {\n        return Math.floor(w_scale * (Math.max(0, chrom_pos - this.view_start) + offset));\n    }\n}\n\nclass LinePainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode) {\n        super(data, view_start, view_end, prefs, mode);\n    }\n\n    static get default_prefs() {\n        return {\n            min_value: undefined,\n            max_value: undefined,\n            mode: \"Histogram\",\n            color: \"#000\",\n            overflow_color: \"#F66\"\n        };\n    }\n\n    draw(ctx, width, height, w_scale) {\n        var in_path = false;\n        var min_value = this.prefs.min_value;\n        var max_value = this.prefs.max_value;\n        var vertical_range = max_value - min_value;\n        var height_px = height;\n        var view_start = this.view_start;\n        var mode = this.mode;\n        var data = this.data;\n\n        ctx.save();\n\n        // Pixel position of 0 on the y axis\n        var y_zero = Math.round(height + min_value / vertical_range * height);\n\n        // Horizontal line to denote x-axis\n        if (mode !== \"Intensity\") {\n            ctx.fillStyle = \"#aaa\";\n            ctx.fillRect(0, y_zero, width, 1);\n        }\n\n        ctx.beginPath();\n        var x_scaled;\n        var y;\n        var delta_x_pxs;\n        if (data.length > 1) {\n            delta_x_pxs = _.map(data.slice(0, -1), (d, i) => Math.ceil((data[i + 1][0] - data[i][0]) * w_scale));\n        } else {\n            delta_x_pxs = [10];\n        }\n\n        // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n        var painter_color = this.prefs.block_color || this.prefs.color;\n\n        var // Extract RGB from preference color.\n        pref_color = parseInt(painter_color.slice(1), 16);\n        var pref_r = (pref_color & 0xff0000) >> 16;\n        var pref_g = (pref_color & 0x00ff00) >> 8;\n        var pref_b = pref_color & 0x0000ff;\n        var top_overflow = false;\n        var bot_overflow = false;\n\n        // Paint track.\n        var delta_x_px;\n        for (var i = 0, len = data.length; i < len; i++) {\n            // Reset attributes for next point.\n            ctx.fillStyle = ctx.strokeStyle = painter_color;\n            top_overflow = bot_overflow = false;\n            delta_x_px = delta_x_pxs[i];\n\n            x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n            y = data[i][1];\n\n            // Process Y (scaler) value.\n            if (y === null) {\n                if (in_path && mode === \"Filled\") {\n                    ctx.lineTo(x_scaled, height_px);\n                }\n                in_path = false;\n                continue;\n            }\n\n            // Bound Y value by min, max.\n            if (y < min_value) {\n                bot_overflow = true;\n                y = min_value;\n            } else if (y > max_value) {\n                top_overflow = true;\n                y = max_value;\n            }\n\n            // Draw point.\n            if (mode === \"Histogram\") {\n                // y becomes the bar height in pixels, which is the negated for canvas coords\n                y = Math.round(y / vertical_range * height_px);\n                ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n            } else if (mode === \"Intensity\") {\n                var saturation = (y - min_value) / vertical_range;\n\n                var // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation));\n\n                var new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation));\n                var new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n                ctx.fillStyle = `rgb(${new_r},${new_g},${new_b})`;\n                ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n            } else {\n                // mode is Coverage/Line or Filled.\n\n                // Scale Y value.\n                y = Math.round(height_px - (y - min_value) / vertical_range * height_px);\n                if (in_path) {\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    in_path = true;\n                    if (mode === \"Filled\") {\n                        ctx.moveTo(x_scaled, height_px);\n                        ctx.lineTo(x_scaled, y);\n                    } else {\n                        ctx.moveTo(x_scaled, y);\n                        // Use this approach (note: same as for filled) to draw line from 0 to\n                        // first data point.\n                        //ctx.moveTo(x_scaled, height_px);\n                        //ctx.lineTo(x_scaled, y);\n                    }\n                }\n            }\n\n            // Draw lines at boundaries if overflowing min or max\n            ctx.fillStyle = this.prefs.overflow_color;\n            if (top_overflow || bot_overflow) {\n                var overflow_x;\n                if (mode === \"Histogram\" || mode === \"Intensity\") {\n                    overflow_x = delta_x_px;\n                } else {\n                    // Line and Filled, which are points\n                    x_scaled -= 2; // Move it over to the left so it's centered on the point\n                    overflow_x = 4;\n                }\n                if (top_overflow) {\n                    ctx.fillRect(x_scaled, 0, overflow_x, 3);\n                }\n                if (bot_overflow) {\n                    ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n                }\n            }\n            ctx.fillStyle = painter_color;\n        }\n        if (mode === \"Filled\") {\n            if (in_path) {\n                ctx.lineTo(x_scaled, y_zero);\n                ctx.lineTo(0, y_zero);\n            }\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    }\n}\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nclass FeaturePositionMapper {\n    constructor(slot_height) {\n        this.feature_positions = {};\n        this.slot_height = slot_height;\n        this.translation = 0;\n        this.y_translation = 0;\n    }\n\n    /**\n     * Map feature data to a position defined by <slot, x_start, x_end>.\n     */\n    map_feature_data(feature_data, slot, x_start, x_end) {\n        if (!this.feature_positions[slot]) {\n            this.feature_positions[slot] = [];\n        }\n        this.feature_positions[slot].push({\n            data: feature_data,\n            x_start: x_start,\n            x_end: x_end\n        });\n    }\n\n    /**\n     * Get feature data for position <x, y>\n     */\n    get_feature_data(x, y) {\n        // Find slot using Y.\n        var slot = Math.floor((y - this.y_translation) / this.slot_height);\n\n        var feature_dict;\n\n        // May not be over a slot due to padding, margin, etc.\n        if (!this.feature_positions[slot]) {\n            return null;\n        }\n\n        // Find feature using X.\n        x += this.translation;\n        for (var i = 0; i < this.feature_positions[slot].length; i++) {\n            feature_dict = this.feature_positions[slot][i];\n            if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n                return feature_dict.data;\n            }\n        }\n    }\n}\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nclass FeaturePainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        super(data, view_start, view_end, prefs, mode);\n        this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n        this.height_scaler = height_scaler ? height_scaler : new Scaler();\n        this.max_label_length = 200;\n    }\n\n    static get default_prefs() {\n        return {\n            block_color: \"#FFF\",\n            connector_color: \"#FFF\"\n        };\n    }\n    get_required_height(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height();\n\n        var y_scale = required_height;\n        var mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    }\n\n    /** Extra padding before first row of features */\n    get_top_padding(width) {\n        return 0;\n    }\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw(ctx, width, height, w_scale, slots) {\n        ctx.save();\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height();\n        var feature_mapper = new FeaturePositionMapper(y_scale);\n        var x_draw_coords;\n        var incomplete_features = [];\n\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i];\n            var feature_uid = feature[0];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n\n            // Slot valid only if features are slotted and this feature is slotted;\n            // feature may not be due to lack of space.\n            var slot = slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if (\n                (this.mode === \"Dense\" || slot !== null) &&\n                (feature_start < this.view_end && feature_end > this.view_start)\n            ) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    this.view_start,\n                    this.view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < this.view_start || feature_end > this.view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    }\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        return [0, 0];\n    }\n}\n\nclass LinkedFeaturePainter extends FeaturePainter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        super(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n        this.draw_background_connector = true;\n        // Whether to call draw_connector for every pair of blocks\n        this.draw_individual_connectors = false;\n    }\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    }\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        // var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n        var feature_strand = feature[4];\n        // -0.5 to offset region between bases.\n        var f_start = Math.floor(Math.max(0, (feature_start - tile_low - 0.5) * w_scale));\n        var f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)));\n        var draw_start = f_start;\n        var draw_end = f_end;\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale + this.get_top_padding(width);\n        var thick_start = null;\n        var thick_end = null;\n\n        // TODO: is there any reason why block, label color cannot be set at the Painter level?\n        // For now, assume '.' === '+'\n        var block_color =\n            !feature_strand || feature_strand === \"+\" || feature_strand === \".\"\n                ? this.prefs.block_color\n                : this.prefs.reverse_strand_color;\n        var label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5];\n\n            var feature_te = feature[6];\n            var feature_blocks = feature[7];\n\n            var // Whether we are drawing full height or squished features\n            full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(Math.max(0, (feature_ts - tile_low) * w_scale));\n                thick_end = Math.ceil(Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)));\n            }\n\n            // Set vars that depend on mode.\n            var thin_height;\n\n            var thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                    }\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start;\n\n                var cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand\");\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand\");\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                }\n\n                // Draw blocks.\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k];\n\n                    var // -0.5 to offset block between bases.\n                    block_start = Math.floor(Math.max(0, (block[0] - tile_low - 0.5) * w_scale));\n\n                    var block_end = Math.ceil(Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale)));\n\n                    var last_block_start;\n                    var last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(block_start, thick_start);\n\n                        var block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(ctx, last_block_start, last_block_end, block_start, block_end, y_start);\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature);\n\n                    var // Ceil ensures that min height is >= 1.\n                    new_height = Math.ceil(thick_height * hscale_factor);\n\n                    var ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                        ctx.fillRect(f_start, cur_y_start + thick_height - ws_height + 1, f_end - f_start, ws_height);\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n}\n\nclass ReadPainter extends FeaturePainter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler, ref_seq, base_color_fn) {\n        super(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        this.ref_seq = ref_seq ? ref_seq.data : null;\n        this.base_color_fn = base_color_fn;\n    }\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height() {\n        var height;\n        var mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    }\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]];\n\n        var cur_block = blocks[0];\n        var base_pos = 0;\n\n        var // Parse cigar operations out and update/create blocks as needed.\n        parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), op => {\n            // Get operation length, character.\n            var op_len = parseInt(op.slice(0, -1), 10),\n                op_char = op.slice(-1);\n\n            // Update drawing block.\n            if (op_char === \"N\") {\n                // At skip, so need to start new block if current block represents\n                // drawing area.\n                if (cur_block[1] !== 0) {\n                    cur_block = [base_pos + op_len, base_pos + op_len];\n                    blocks.push(cur_block);\n                }\n            } else if (\"ISHP\".indexOf(op_char) === -1) {\n                // Operation is M,D,=,X.\n                cur_block[1] += op_len;\n                base_pos += op_len;\n            }\n\n            // Return parsed cigar.\n            return [cigar_ops.indexOf(op_char), op_len];\n        });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    }\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = (offset, cig_op, cig_len) => {\n            if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var update_seq_offset = (offset, cig_op, cig_len) => {\n            if (\"IX\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n        get_draw_coord = (\n            sequence_coord // -0.5 to offset sequence between bases.\n        ) => Math.floor(Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale));\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high];\n        var base_offset = 0;\n        var seq_offset = 0;\n        var gap = Math.round(w_scale / 2);\n        var char_width_px = ctx.canvas.manager.char_width_px;\n\n        var block_color = strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color;\n\n        var pack_mode = mode === \"Pack\";\n\n        var draw_height = pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        var rect_y = y_start + 1;\n        var paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode);\n        var drawing_blocks = [];\n        var s_start;\n        var s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id];\n            var cig_op = \"MIDNSHP=X\"[cig[0]];\n            var cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (let c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if ((cur_seq && !this.prefs.show_differences) || cig_op === \"X\") {\n                            // Draw base.\n                            let c_start = Math.floor(Math.max(0, (start_pos + c - tile_low) * w_scale));\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(c_start - gap, rect_y, Math.max(1, Math.round(w_scale)), draw_height);\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(s_start, rect_y + (draw_height - 1) / 2, s_end - s_start, 1);\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                        var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(0, seq_start - tile_high);\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(tile_low - seq_start, seq_start - tile_high);\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (let c = 0, str_len = seq.length; c < str_len; c++) {\n                                    let c_start = Math.floor(Math.max(0, (seq_start + c - tile_low) * w_scale));\n                                    ctx.fillText(seq[c], c_start - (s_end - s_start) / 2, y_start);\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [seq.length, insert_x_coord, y_start + 9]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item;\n        var type;\n        var data;\n        for (let i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = `bold ${ctx.font}`;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    }\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        // All features need a start, end, and vertical center.\n        // var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n\n        var // -0.5 to put element between bases.\n        f_start = Math.floor(Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale));\n\n        var f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)));\n\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale;\n\n        var draw_height = mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale))\n            );\n\n            var b2_start = Math.floor(Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale));\n\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n}\n\nclass ArcLinkedFeaturePainter extends LinkedFeaturePainter {\n    constructor(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        super(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        // Need to know the longest feature length for adding spacing\n        this.longest_feature_length = this.calculate_longest_feature_length();\n        this.draw_background_connector = false;\n        this.draw_individual_connectors = true;\n    }\n\n    calculate_longest_feature_length() {\n        var longest_feature_length = 0;\n        for (let i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n            longest_feature_length = Math.max(longest_feature_length, feature_end - feature_start);\n        }\n        return longest_feature_length;\n    }\n\n    get_top_padding(width) {\n        var view_range = this.view_end - this.view_start;\n        var w_scale = width / view_range;\n        return Math.min(128, Math.ceil(this.longest_feature_length / 2 * w_scale));\n    }\n\n    draw_connector(ctx, block1_start, block1_end, block2_start, block2_end, y_start) {\n        // Arc drawing -- from closest endpoints\n        var x_center = (block1_end + block2_start) / 2;\n        var radius = block2_start - x_center;\n        if (radius > 0) {\n            ctx.beginPath();\n            ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n            ctx.stroke();\n        }\n    }\n}\n\n// Color stuff from less.js\n\nclass Color {\n    constructor(rgb, a) {\n        /**\n         * The end goal here, is to parse the arguments\n         * into an integer triplet, such as `128, 255, 0`\n         *\n         * This facilitates operations and conversions.\n         */\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length == 6) {\n            this.rgb = rgb.match(/.{2}/g).map(c => parseInt(c, 16));\n        } else if (rgb.length == 7) {\n            this.rgb = rgb\n                .substring(1, 7)\n                .match(/.{2}/g)\n                .map(c => parseInt(c, 16));\n        } else {\n            this.rgb = rgb.split(\"\").map(c => parseInt(c + c, 16));\n        }\n        this.alpha = typeof a === \"number\" ? a : 1;\n    }\n\n    eval() {\n        return this;\n    }\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS() {\n        if (this.alpha < 1.0) {\n            return `rgba(${this.rgb\n                .map(c => Math.round(c))\n                .concat(this.alpha)\n                .join(\", \")})`;\n        } else {\n            return `#${this.rgb\n                .map(i => {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? `0${i}` : i;\n                })\n                .join(\"\")}`;\n        }\n    }\n\n    toHSL() {\n        var r = this.rgb[0] / 255;\n        var g = this.rgb[1] / 255;\n        var b = this.rgb[2] / 255;\n        var a = this.alpha;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h;\n        var s;\n        var l = (max + min) / 2;\n        var d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    }\n\n    toARGB() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return `#${argb\n            .map(i => {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                return i.length === 1 ? `0${i}` : i;\n            })\n            .join(\"\")}`;\n    }\n\n    mix(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n}\n\n// End colors from less.js\n\nclass LinearRamp {\n    constructor(start_color, end_color, start_value, end_value) {\n        /**\n         * Simple linear gradient\n         */\n        this.start_color = new Color(start_color);\n        this.end_color = new Color(end_color);\n        this.start_value = start_value;\n        this.end_value = end_value;\n        this.value_range = end_value - start_value;\n    }\n\n    map_value(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        value = (value - this.start_value) / this.value_range;\n        // HACK: just red for now\n        // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n        return this.start_color.mix(this.end_color, 1 - value).toCSS();\n    }\n}\n\nclass SplitRamp {\n    constructor(start_color, middle_color, end_color, start_value, end_value) {\n        /**\n         * Two gradients split away from 0\n         */\n        this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n        this.negative_ramp = new LinearRamp(middle_color, start_color, 0, -start_value);\n        this.start_value = start_value;\n        this.end_value = end_value;\n    }\n\n    map_value(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        if (value >= 0) {\n            return this.positive_ramp.map_value(value);\n        } else {\n            return this.negative_ramp.map_value(-value);\n        }\n    }\n}\n\nclass DiagonalHeatmapPainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode) {\n        super(data, view_start, view_end, prefs, mode);\n        var i;\n        var len;\n\n        if (this.prefs.min_value === undefined) {\n            var min_value = Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                min_value = Math.min(min_value, this.data[i][6]);\n            }\n            this.prefs.min_value = min_value;\n        }\n        if (this.prefs.max_value === undefined) {\n            var max_value = -Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                max_value = Math.max(max_value, this.data[i][6]);\n            }\n            this.prefs.max_value = max_value;\n        }\n    }\n\n    static get default_prefs() {\n        return {\n            min_value: undefined,\n            max_value: undefined,\n            mode: \"Heatmap\",\n            pos_color: \"#FF8C00\",\n            neg_color: \"#4169E1\"\n        };\n    }\n\n    draw(ctx, width, height, w_scale) {\n        var min_value = this.prefs.min_value;\n        var max_value = this.prefs.max_value;\n        var view_start = this.view_start;\n        var invsqrt2 = 1 / Math.sqrt(2);\n\n        var ramp = new SplitRamp(this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value);\n\n        var d;\n        var s1;\n        var e1;\n        var s2;\n        var e2;\n        var value;\n\n        var scale = p => (p - view_start) * w_scale;\n\n        ctx.save();\n\n        // Draw into triangle, then rotate and scale\n        ctx.rotate(-45 * Math.PI / 180);\n        ctx.scale(invsqrt2, invsqrt2);\n\n        // Paint track.\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            d = this.data[i];\n\n            s1 = scale(d[1]);\n            e1 = scale(d[2]);\n            s2 = scale(d[4]);\n            e2 = scale(d[5]);\n            value = d[6];\n\n            ctx.fillStyle = ramp.map_value(value);\n            ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n        }\n\n        ctx.restore();\n    }\n}\n\n/**\n * Utilities for painting reads.\n */\nclass ReadPainterUtils {\n    constructor(ctx, row_height, px_per_base, mode) {\n        this.ctx = ctx;\n        this.row_height = row_height;\n        this.px_per_base = px_per_base;\n        this.draw_details = (mode === \"Pack\" || mode === \"Auto\") && px_per_base >= ctx.canvas.manager.char_width_px;\n        this.delete_details_thickness = 0.2;\n    }\n\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n}\n\n/**\n * Paints variant data onto canvas.\n */\nclass VariantPainter extends Painter {\n    constructor(data, view_start, view_end, prefs, mode, base_color_fn) {\n        super(data, view_start, view_end, prefs, mode);\n        this.base_color_fn = base_color_fn;\n        this.divider_height = 1;\n    }\n\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    }\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    }\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = (ref, alt) => {\n            var ref_len = ref.length;\n            var alt_len = alt.length;\n            var start = 0;\n            var len = 1;\n            var type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data;\n\n        var pos;\n        var ref;\n        var alt;\n        var sample_gts;\n        var allele_counts;\n        var variant;\n        var draw_x_start;\n        var draw_y_start;\n        var genotype;\n\n        var // Always draw variants at least 1 pixel wide.\n        base_px = Math.max(1, Math.floor(w_scale));\n\n        var // Determine number of samples.\n        num_samples = this.data.length ? this.data[0][7].split(\",\").length : 0;\n\n        var row_height = this.mode === \"Squish\" ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT;\n\n        var // If zoomed out, fill the whole row with feature to make it easier to read;\n        // when zoomed in, use feature height so that there are gaps in sample rows.\n        feature_height =\n            w_scale < 0.1 ? row_height : this.mode === \"Squish\" ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT;\n\n        var draw_summary = true;\n\n        var paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode);\n\n        var j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), a => {\n                var alt_info = {\n                    type: \"snp\",\n                    value: a,\n                    start: 0\n                };\n\n                var indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                    ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle = alt[j].type === \"deletion\" ? \"black\" : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                        ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary ? this.prefs.summary_height + this.divider_height : 0;\n            for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                genotype = sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                        } else {\n                            ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n}\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}