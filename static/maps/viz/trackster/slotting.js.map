{"version":3,"sources":["viz/trackster/slotting.js"],"names":["_","extend","LABEL_SPACING","PACK_SPACING","SlottedInfo","slot","feature","FeatureSlotter","w_scale","mode","max_rows","measureText","slots","start_end_dct","include_label","prototype","_get_draw_coords","draw_start","Math","floor","draw_end","ceil","f_name","undefined","text_len","width","_find_slot","draw_coords","slot_num","has_overlap","k","k_len","length","s_e","slot_features","features","undone","highest_slot","feature_uid","i","len","slotted_info","old_draw_coords","new_draw_coords","slotted_coords","dc","max","push"],"mappings":"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","file":"../../../scripts/viz/trackster/slotting.js","sourcesContent":["import * as _ from \"libs/underscore\";\nvar extend = _.extend;\n\n// HACK: LABEL_SPACING is currently duplicated between here and painters\nvar LABEL_SPACING = 2;\n\nvar PACK_SPACING = 5;\n\n/**\n * Hold slotting information for a feature.\n */\nvar SlottedInfo = function(slot, feature) {\n    this.slot = slot;\n    this.feature = feature;\n};\n\n/**\n * FeatureSlotter determines slots in which to draw features for vertical\n * packing.\n *\n * This implementation is incremental, any feature assigned a slot will be\n * retained for slotting future features.\n */\nvar FeatureSlotter = function(w_scale, mode, max_rows, measureText) {\n    this.slots = {};\n    this.start_end_dct = {};\n    this.w_scale = w_scale;\n    this.mode = mode;\n    this.include_label = mode === \"Pack\";\n    this.max_rows = max_rows;\n    this.measureText = measureText;\n};\n\n/**\n * Slot a set of features, `this.slots` will be updated with slots by id, and\n * the largest slot required for the passed set of features is returned\n */\nextend(FeatureSlotter.prototype, {\n    /**\n     * Get drawing coordinate for a feature.\n     */\n    _get_draw_coords: function(feature) {\n        // Get initial draw coordinates using w_scale.\n        var draw_start = Math.floor(feature[1] * this.w_scale);\n\n        var draw_end = Math.ceil(feature[2] * this.w_scale);\n        var f_name = feature[3];\n        //var text_align;\n\n        // Update start, end drawing locations to include feature name.\n        // Try to put the name on the left, if not, put on right.\n        if (f_name !== undefined && this.include_label) {\n            // Add gap for label spacing and extra pack space padding\n            // TODO: Fix constants\n            var text_len = this.measureText(f_name).width + (LABEL_SPACING + PACK_SPACING);\n            if (draw_start - text_len >= 0) {\n                draw_start -= text_len;\n                //text_align = \"left\";\n            } else {\n                draw_end += text_len;\n                //text_align = \"right\";\n            }\n        }\n\n        /*\n        if (slot_num < 0) {\n            \n            TODO: this is not yet working --\n            console.log(feature_uid, \"looking for slot with text on the right\");\n            // Slot not found. If text was on left, try on right and see\n            // if slot can be found.\n            // TODO: are there any checks we need to do to ensure that text\n            // will fit on tile?\n            if (text_align === \"left\") {\n                draw_start -= text_len;\n                draw_end -= text_len;\n                text_align = \"right\";\n                slot_num = find_slot(draw_start, draw_end);\n            }\n            if (slot_num >= 0) {\n                console.log(feature_uid, \"found slot with text on the right\");\n            }\n\n        }\n        */\n\n        return [draw_start, draw_end];\n    },\n\n    /**\n     * Find the first slot such that current feature doesn't overlap any other features in that slot.\n     * Returns -1 if no slot was found.\n     */\n    _find_slot: function(draw_coords) {\n        // TODO: Use a data structure for faster searching of available slots.\n        var draw_start = draw_coords[0];\n\n        var draw_end = draw_coords[1];\n        for (var slot_num = 0; slot_num <= this.max_rows; slot_num++) {\n            var has_overlap = false;\n            var slot = this.start_end_dct[slot_num];\n            if (slot !== undefined) {\n                // Iterate through features already in slot to see if current feature will fit.\n                for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                    var s_e = slot[k];\n                    if (draw_end > s_e[0] && draw_start < s_e[1]) {\n                        // There is overlap\n                        has_overlap = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_overlap) {\n                return slot_num;\n            }\n        }\n        return -1;\n    },\n\n    /**\n     * Slot features.\n     */\n    slot_features: function(features) {\n        var start_end_dct = this.start_end_dct;\n        var undone = [];\n        var highest_slot = 0;\n        var feature;\n        var feature_uid;\n\n        // Loop through features to (a) find those that are not yet slotted and (b) update\n        // those that are slotted if new information is availabe. For (a), features already\n        // slotted (based on slotting from other tiles) will retain their current slot.\n        for (let i = 0, len = features.length; i < len; i++) {\n            feature = features[i];\n            feature_uid = feature[0];\n            var slotted_info = this.slots[feature_uid];\n\n            // Separate and handle slotted vs. unslotted features.\n            if (slotted_info) {\n                // Feature is slotted; if feature now has larger start/end coordinates,\n                // update drawing coordinates.\n                if (feature[1] < slotted_info.feature[1] || slotted_info.feature[2] < feature[2]) {\n                    // Feature has changed (e.g. a single read now has its pair), so recalculate its\n                    // drawing coordinates.\n                    var old_draw_coords = this._get_draw_coords(slotted_info.feature);\n\n                    var new_draw_coords = this._get_draw_coords(feature);\n                    var slotted_coords = this.start_end_dct[slotted_info.slot];\n                    for (var k = 0; k < slotted_coords.length; k++) {\n                        var dc = slotted_coords[k];\n                        if (dc[0] === old_draw_coords[0] && dc[1] === old_draw_coords[1]) {\n                            // Replace old drawing coordinates with new ones.\n                            slotted_coords[k] = new_draw_coords;\n                        }\n                    }\n                }\n                highest_slot = Math.max(highest_slot, this.slots[feature_uid].slot);\n            } else {\n                undone.push(i);\n            }\n        }\n\n        // Slot unslotted features.\n\n        // Do slotting.\n        for (let i = 0, len = undone.length; i < len; i++) {\n            feature = features[undone[i]];\n            feature_uid = feature[0];\n            var draw_coords = this._get_draw_coords(feature);\n\n            // Find slot.\n            var slot_num = this._find_slot(draw_coords);\n\n            // Do slotting.\n            if (slot_num >= 0) {\n                // Add current feature to slot.\n                if (start_end_dct[slot_num] === undefined) {\n                    start_end_dct[slot_num] = [];\n                }\n                start_end_dct[slot_num].push(draw_coords);\n                this.slots[feature_uid] = new SlottedInfo(slot_num, feature);\n                highest_slot = Math.max(highest_slot, slot_num);\n            }\n        }\n\n        // Debugging: view slots data.\n        /*\n        for (var i = 0; i < MAX_FEATURE_DEPTH; i++) {\n            var slot = start_end_dct[i];\n            if (slot !== undefined) {\n                console.log(i, \"*************\");\n                for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                    console.log(\"\\t\", slot[k][0], slot[k][1]);\n                }\n            }\n        }\n        */\n        return highest_slot + 1;\n    }\n});\n\nexport default {\n    FeatureSlotter: FeatureSlotter\n};\n"]}